import { createLocalVue } from '@vue/test-utils';
import VueApollo from 'vue-apollo';
import { nextTick } from 'vue';
import { GlIntersectionObserver } from '@gitlab/ui';
import VulnerabilityList from 'ee/security_dashboard/components/shared/vulnerability_report/vulnerability_list.vue';
import VulnerabilityReportDevelopment from 'ee/security_dashboard/components/group/vulnerability_report_development.vue';
import VulnerabilityCounts from 'ee/security_dashboard/components/shared/vulnerability_report/vulnerability_counts.vue';
import VulnerabilityFilters from 'ee/security_dashboard/components/shared/vulnerability_report/vulnerability_filters.vue';
import { shallowMountExtended } from 'helpers/vue_test_utils_helper';
import vulnerabilitiesQuery from 'ee/security_dashboard/graphql/queries/group_vulnerabilities.query.graphql';
import createMockApollo from 'helpers/mock_apollo_helper';
import createFlash from '~/flash';

jest.mock('~/flash');

const localVue = createLocalVue();
localVue.use(VueApollo);

const groupFullPath = 'path';

const createVulnerabilitiesRequestHandler = ({ hasNextPage }) =>
  jest.fn().mockResolvedValue({
    data: {
      group: {
        vulnerabilities: {
          nodes: [],
          pageInfo: { endCursor: 'abc', hasNextPage },
        },
      },
    },
  });

const vulnerabilitiesRequestHandler = createVulnerabilitiesRequestHandler({ hasNextPage: true });

describe('Vulnerability counts component', () => {
  let wrapper;

  const createWrapper = ({
    vulnerabilitiesHandler = vulnerabilitiesRequestHandler,
    canViewFalsePositive = true,
    filters = {},
  } = {}) => {
    wrapper = shallowMountExtended(VulnerabilityReportDevelopment, {
      localVue,
      apolloProvider: createMockApollo([[vulnerabilitiesQuery, vulnerabilitiesHandler]]),
      provide: {
        groupFullPath,
        canViewFalsePositive,
        canAdminVulnerability: true,
        hasProjects: true,
      },
      data: () => ({ filters }),
    });
  };

  const findVulnerabilityCounts = () => wrapper.findComponent(VulnerabilityCounts);
  const findVulnerabilityFilters = () => wrapper.findComponent(VulnerabilityFilters);
  const findVulnerabilityList = () => wrapper.findComponent(VulnerabilityList);
  const findIntersectionObserver = () => wrapper.findComponent(GlIntersectionObserver);

  afterEach(() => {
    wrapper.destroy();
    vulnerabilitiesRequestHandler.mockClear();
  });

  describe('vulnerability counts component', () => {
    it('receives the filters prop from the filters component', () => {
      const filters = {}; // Object itself does not matter, we're only checking that it's passed.
      createWrapper({ filters });

      expect(findVulnerabilityCounts().props('filters')).toBe(filters);
    });
  });

  describe('group vulnerabilities query', () => {
    it('calls the query once with the expected fullPath variable', () => {
      createWrapper();

      expect(vulnerabilitiesRequestHandler).toHaveBeenCalledTimes(1);
      expect(vulnerabilitiesRequestHandler).toHaveBeenCalledWith(
        expect.objectContaining({ fullPath: groupFullPath }),
      );
    });

    it.each([true, false])(
      'calls the query with the expected vetEnabled property when canViewFalsePositive is %s',
      (canViewFalsePositive) => {
        createWrapper({ canViewFalsePositive });

        expect(vulnerabilitiesRequestHandler).toHaveBeenCalledWith(
          expect.objectContaining({ vetEnabled: canViewFalsePositive }),
        );
      },
    );

    it('does not call the query if filters are not ready', () => {
      createWrapper({ filters: null });

      expect(vulnerabilitiesRequestHandler).not.toHaveBeenCalled();
    });

    it('shows an error message if the query fails', async () => {
      const vulnerabilitiesHandler = jest.fn().mockRejectedValue(new Error());
      createWrapper({ vulnerabilitiesHandler });
      // Have to wait 2 ticks here, one for the query to finish loading, and one more for the
      // GraphQL error handler to be called.
      await nextTick();
      await nextTick();

      expect(createFlash).toHaveBeenCalledTimes(1);
    });
  });

  describe('vulnerability list component', () => {
    it('gets the expected vulnerabilities prop', async () => {
      createWrapper();

      const vulnerabilities = [];
      await wrapper.setData({ vulnerabilities });

      expect(findVulnerabilityList().props('vulnerabilities')).toEqual(vulnerabilities);
    });

    it('calls the vulnerabilities query with the data from the sort-changed event', async () => {
      createWrapper();
      // First call should be undefined, which uses the default sort.
      expect(vulnerabilitiesRequestHandler).toHaveBeenCalledWith(
        expect.objectContaining({ sort: undefined }),
      );

      const sort = 'sort';
      findVulnerabilityList().vm.$emit('sort-changed', sort);
      await nextTick();

      expect(vulnerabilitiesRequestHandler).toHaveBeenCalledWith(expect.objectContaining({ sort }));
    });
  });

  describe('intersection observer', () => {
    it('is not shown when the vulnerabilities query is loading for the first time', () => {
      createWrapper();

      expect(findIntersectionObserver().exists()).toBe(false);
    });

    it('will fetch more data when the appear event is fired', async () => {
      createWrapper();
      await nextTick();
      const spy = jest.spyOn(wrapper.vm.$apollo.queries.vulnerabilities, 'fetchMore');

      findIntersectionObserver().vm.$emit('appear');

      expect(spy).toHaveBeenCalledTimes(1);
    });

    it('is not shown if there is no next page', async () => {
      createWrapper({
        vulnerabilitiesHandler: createVulnerabilitiesRequestHandler({ hasNextPage: false }),
      });

      await nextTick();

      expect(findIntersectionObserver().exists()).toBe(false);
    });
  });

  describe('vulnerability filters component', () => {
    it('will pass data from filters-changed event to vulnerabilities GraphQL query', async () => {
      const vulnerabilitiesHandler = jest.fn().mockResolvedValue();
      createWrapper({ vulnerabilitiesHandler });
      // Sanity check, the report component will call this the first time it's mounted.
      expect(vulnerabilitiesHandler).toHaveBeenCalledTimes(1);

      const data = { a: 1 };
      findVulnerabilityFilters().vm.$emit('filters-changed', data);
      await nextTick();

      expect(vulnerabilitiesHandler).toHaveBeenCalledTimes(2);
      expect(vulnerabilitiesHandler).toHaveBeenCalledWith(expect.objectContaining(data));
    });
  });
});
